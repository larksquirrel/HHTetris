<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>黑黑花花的俄罗斯方块</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #0f0b1e 0%, #1a0f2e 100%);
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 5px;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin: 5px 0 8px;
            width: 100%;
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 3px;
            background: linear-gradient(to right, #ff2a8f, #ff7eb3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(255, 42, 143, 0.3);
        }

        .subtitle {
            color: #ff9ec9;
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: calc(100vh - 120px);
            max-width: 900px;
        }

        .main-game {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            flex: 1;
            width: 100%;
        }

        /* 游戏棋盘区域 */
        .game-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, rgba(20, 10, 30, 0.9), rgba(30, 15, 40, 0.9));
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 8px 20px rgba(255, 42, 143, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 122, 179, 0.2);
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(20, 1fr);
            width: 100%;
            height: 100%;
            max-width: 300px;
            max-height: 600px;
            background-color: rgba(10, 5, 20, 0.9);
            border: 2px solid rgba(255, 122, 179, 0.3);
            border-radius: 6px;
            overflow: hidden;
            transition: background-color 0.5s, filter 0.5s;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            aspect-ratio: 1/2;
        }

        /* 游戏信息区域 */
        .game-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
        }

        .info-panel {
            background: linear-gradient(145deg, rgba(20, 10, 30, 0.9), rgba(30, 15, 40, 0.9));
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(255, 42, 143, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 122, 179, 0.2);
        }

        .info-title {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #ff7eb3;
            text-align: center;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .score-display {
            font-size: 2.2rem;
            text-align: center;
            font-weight: bold;
            color: #ff4d9e;
            margin: 5px 0;
            text-shadow: 0 2px 8px rgba(255, 77, 158, 0.5);
        }

        .next-piece-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .next-piece-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 90px;
            height: 90px;
            background-color: rgba(10, 5, 20, 0.9);
            border-radius: 6px;
            margin-top: 5px;
            border: 1px solid rgba(255, 122, 179, 0.3);
        }

        .items-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .item {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(145deg, rgba(30, 15, 40, 0.9), rgba(20, 10, 30, 0.9));
        }

            .item:active {
                transform: scale(0.95);
            }

            .item.disabled {
                opacity: 0.5;
                filter: grayscale(0.7);
                cursor: not-allowed;
                pointer-events: none;
            }

            .item.recovered {
                border-left-width: 6px;
                box-shadow: 0 5px 15px rgba(255, 255, 255, 0.2);
            }

        .item-content {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 10px;
            height: 100%;
        }

        .item-name {
            font-weight: bold;
            font-size: 0.9rem;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            margin-bottom: 5px;
        }

        .item-count {
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            color: #ff7eb3;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            align-self: flex-end;
            margin-top: auto;
        }

        .item-recovery {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            z-index: 1;
            transition: width 0.3s ease;
            opacity: 0.5;
        }

        /* 道具颜色 */
        .item.mojing {
            border-left-color: #ffffff;
        }

        .item.haitang {
            border-left-color: #ff4081;
        }

        .item.sodawater {
            border-left-color: #2196f3;
        }

        .item.qingjunce {
            border-left-color: #ffc107;
        }

        .item.mojing .item-recovery {
            background: linear-gradient(90deg, #000000 0%, #333333 100%);
        }

        .item.haitang .item-recovery {
            background: linear-gradient(90deg, #ff2a8f 0%, #ff7eb3 100%);
        }

        .item.sodawater .item-recovery {
            background: linear-gradient(90deg, #2196f3 0%, #64b5f6 100%);
        }

        .item.qingjunce .item-recovery {
            background: linear-gradient(90deg, #ffc107 0%, #ffd54f 100%);
        }

        /* 控制按钮区域 */
        .controls-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            padding: 10px 0;
            width: 100%;
        }

        .game-button {
            background: linear-gradient(to bottom, #ff2a8f, #ff4d9e);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 24px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 42, 143, 0.3);
            flex: 1;
            max-width: 180px;
            min-width: 120px;
        }

            .game-button:active {
                transform: scale(0.95);
            }

            .game-button.pause {
                background: linear-gradient(to bottom, #ff7eb3, #ff9ec9);
            }

            .game-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

        /* 游戏状态 */
        .game-status {
            text-align: center;
            margin-top: 8px;
            font-size: 1rem;
            font-weight: bold;
            height: 24px;
            color: #ff7eb3;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        /* 格子样式 */
        .cell {
            width: 100%;
            height: 100%;
            border: 1px solid rgba(255, 122, 179, 0.1);
        }

        .filled {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }

        /* 方块颜色 */
        .i {
            background-color: #00bcd4;
        }

        .j {
            background-color: #2196f3;
        }

        .l {
            background-color: #ff9800;
        }

        .o {
            background-color: #ffeb3b;
        }

        .s {
            background-color: #4caf50;
        }

        .t {
            background-color: #9c27b0;
        }

        .z {
            background-color: #f44336;
        }

        /* 夜幕降临效果 */
        .night-fall {
            background-color: #000 !important;
            filter: brightness(0.1);
        }

        /* 冤魂效果 */
        .yuan-ghost .cell.filled.i,
        .yuan-ghost .cell.filled.j,
        .yuan-ghost .cell.filled.l,
        .yuan-ghost .cell.filled.o,
        .yuan-ghost .cell.filled.s,
        .yuan-ghost .cell.filled.t,
        .yuan-ghost .cell.filled.z {
            background-color: #000000 !important;
            border-color: #444444 !important;
        }

        /* 流血天气效果 */
        .blood-weather .cell.filled.i,
        .blood-weather .cell.filled.j,
        .blood-weather .cell.filled.l,
        .blood-weather .cell.filled.o,
        .blood-weather .cell.filled.s,
        .blood-weather .cell.filled.t,
        .blood-weather .cell.filled.z {
            background-color: #ff2a2a !important;
            border-color: #ff7a7a !important;
        }

        /* 事件弹窗样式 */
        .event-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(15, 8, 25, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

            .event-modal.active {
                opacity: 1;
                visibility: visible;
            }

        .event-content {
            background: linear-gradient(145deg, rgba(25, 12, 35, 0.95), rgba(35, 17, 45, 0.95));
            border-radius: 16px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 15px 35px rgba(255, 42, 143, 0.2);
            border: 2px solid rgba(255, 122, 179, 0.3);
        }

        .event-title {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #ff7eb3;
            text-shadow: 0 2px 10px rgba(255, 126, 179, 0.5);
        }

        .event-description {
            font-size: 1rem;
            line-height: 1.5;
            margin-bottom: 20px;
            color: #ff9ec9;
        }

        .event-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .event-button {
            background: linear-gradient(to bottom, #ff2a8f, #ff4d9e);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(255, 42, 143, 0.3);
        }

            .event-button:active {
                transform: scale(0.95);
            }

            .event-button.consume {
                background: linear-gradient(to bottom, #ff4d9e, #ff2a8f);
            }

            .event-button.cancel {
                background: linear-gradient(to bottom, #666666, #444444);
            }

        /* 规则弹窗样式 */
        .rules-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(15, 8, 25, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

            .rules-modal.active {
                opacity: 1;
                visibility: visible;
            }

        .rules-content {
            background: linear-gradient(145deg, rgba(25, 12, 35, 0.95), rgba(35, 17, 45, 0.95));
            border-radius: 16px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: 0 15px 35px rgba(255, 42, 143, 0.2);
            border: 2px solid rgba(255, 122, 179, 0.3);
        }

        .rules-title {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #ff7eb3;
            text-shadow: 0 2px 10px rgba(255, 126, 179, 0.5);
        }

        .rules-text {
            text-align: left;
            font-size: 1rem;
            line-height: 1.5;
            color: #ff9ec9;
            margin-bottom: 20px;
        }

        .rule-item {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid;
            background: rgba(255, 122, 179, 0.1);
        }

            .rule-item.mojing-rule {
                border-left-color: #ffffff;
            }

            .rule-item.haitang-rule {
                border-left-color: #ff2a8f;
            }

            .rule-item.sodawater-rule {
                border-left-color: #2196f3;
            }

            .rule-item.qingjunce-rule {
                border-left-color: #ffc107;
            }

            .rule-item strong {
                color: #ffffff;
                font-size: 1rem;
                display: block;
                margin-bottom: 5px;
            }

        .rules-confirm-button {
            background: linear-gradient(to bottom, #ff2a8f, #ff4d9e);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 42, 143, 0.3);
            margin-top: 10px;
        }

            .rules-confirm-button:active {
                transform: scale(0.95);
            }

        /* 竖屏手机优化 */
        @media screen and (orientation: portrait) and (max-width: 768px) {
            .game-container {
                height: calc(100vh - 80px);
            }

            .main-game {
                grid-template-columns: 1.2fr 0.8fr;
                gap: 8px;
            }

            .game-board {
                max-width: 100%;
                max-height: 100%;
            }

            .items-panel {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .item-content {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 8px 10px;
            }

            .item-name {
                margin-bottom: 0;
                font-size: 0.85rem;
            }

            .item-count {
                margin-top: 0;
                font-size: 1.1rem;
            }

            .controls-container {
                gap: 10px;
            }

            .game-button {
                padding: 10px 20px;
                font-size: 1rem;
                max-width: 150px;
                min-width: 100px;
            }
        }

        /* 超小屏幕优化 */
        @media screen and (orientation: portrait) and (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }

            .subtitle {
                font-size: 0.7rem;
            }

            .main-game {
                grid-template-columns: 1.3fr 0.7fr;
                gap: 6px;
            }

            .info-panel {
                padding: 8px;
            }

            .info-title {
                font-size: 0.9rem;
            }

            .score-display {
                font-size: 1.8rem;
            }

            .next-piece-board {
                width: 70px;
                height: 70px;
            }

            .item-name {
                font-size: 0.8rem;
            }

            .item-count {
                font-size: 1rem;
            }

            .game-button {
                padding: 8px 16px;
                font-size: 0.9rem;
                max-width: 130px;
                min-width: 90px;
            }
        }

        /* 横屏布局 */
        @media screen and (orientation: landscape) {
            .main-game {
                grid-template-columns: 1fr 1fr;
            }

            .items-panel {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>黑黑花花的俄罗斯方块</h1>
        <div class="subtitle">🕶️ 黑眼镜 · 🎮 · 解雨臣 🌸</div>
    </div>

    <!-- 游戏规则弹窗 -->
    <div class="rules-modal" id="rules-modal">
        <div class="rules-content">
            <h2 class="rules-title">游戏规则</h2>
            <div class="rules-text">
                <p style="text-align: center; font-weight: bold; margin: 10px 0;">🎉 欢迎来到黑黑花花的俄罗斯方块！🎉</p>
                <p>本游戏在传统的俄罗斯方块上增加了4种【道具】和10种【剧情】</p>
                <p>在消除一行方块后会触发随机【剧情】，需完成相应要求后才能继续游戏</p>
                <p>在游戏过程中可使用右侧【道具】，介绍如下：</p>

                <div class="rule-item mojing-rule">
                    <strong>【墨镜】</strong>
                    <p>用于适应剧情【夜幕降临】</p>
                </div>

                <div class="rule-item haitang-rule">
                    <strong>【海棠】</strong>
                    <p>用于支付剧情【食君之禄】</p>
                </div>

                <div class="rule-item sodawater-rule">
                    <strong>【苏打水】</strong>
                    <p>随机改变下一方块的形状。</p>
                </div>

                <div class="rule-item qingjunce-rule">
                    <strong>【清君侧】</strong>
                    <p>清除现有全部方块。</p>
                </div>
            </div>
            <button class="rules-confirm-button" id="rules-confirm-button">开始游戏</button>
        </div>
    </div>

    <div class="game-container">
        <div class="main-game">
            <!-- 左：棋盘 -->
            <div class="game-board-container">
                <div class="game-board" id="game-board"></div>
                <div class="game-status" id="game-status">准备开始</div>
            </div>

            <!-- 右：信息区 -->
            <div class="game-info">
                <div class="info-panel">
                    <div class="info-title">分数</div>
                    <div class="score-display" id="score">0</div>
                </div>

                <div class="info-panel">
                    <div class="info-title">下一个方块</div>
                    <div class="next-piece-container">
                        <div class="next-piece-board" id="next-piece-board"></div>
                    </div>
                </div>

                <div class="info-panel items-panel">
                    <div class="info-title">道具栏</div>

                    <div class="item mojing" id="mojing-item">
                        <div class="item-recovery" id="mojing-recovery"></div>
                        <div class="item-content">
                            <span class="item-name">🕶️ 墨镜</span>
                            <span class="item-count" id="mojing-count">0</span>
                        </div>
                    </div>

                    <div class="item haitang" id="haitang-item">
                        <div class="item-recovery" id="haitang-recovery"></div>
                        <div class="item-content">
                            <span class="item-name">🌸 海棠</span>
                            <span class="item-count" id="haitang-count">0</span>
                        </div>
                    </div>

                    <div class="item sodawater" id="sodawater-item">
                        <div class="item-recovery" id="sodawater-recovery"></div>
                        <div class="item-content">
                            <span class="item-name">🥤 苏打水</span>
                            <span class="item-count" id="sodawater-count">0</span>
                        </div>
                    </div>

                    <div class="item qingjunce" id="qingjunce-item">
                        <div class="item-recovery" id="qingjunce-recovery"></div>
                        <div class="item-content">
                            <span class="item-name">⚔️ 清君侧</span>
                            <span class="item-count" id="qingjunce-count">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 底部控制按钮 -->
        <div class="controls-container">
            <button class="game-button" id="start-restart-button">开始游戏</button>
            <button class="game-button pause" id="pause-resume-button" disabled>暂停</button>
        </div>
    </div>

    <!-- 音频元素 -->
    <audio id="background-music" loop preload="auto">
        <source src="backgroundmusic.mp3" type="audio/mpeg">
    </audio>
    <audio id="opera-music" preload="auto">
        <source src="xiqu.mp3" type="audio/mpeg">
    </audio>

    <!-- 事件弹窗 -->
    <div class="event-modal" id="event-modal">
        <div class="event-content">
            <h2 class="event-title" id="event-title">事件标题</h2>
            <div class="event-description" id="event-description"></div>
            <div class="event-actions" id="event-actions">
                <!-- 按钮会动态添加 -->
            </div>
        </div>
    </div>

    <script>
        // 游戏常量
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const EMPTY_CELL = 'empty';

        // 道具恢复时间（毫秒）
        const ITEM_RECOVERY_TIMES = {
            mojing: 6000,      // 墨镜：6秒
            haitang: 8000,     // 海棠：8秒
            sodawater: 12000,  // 苏打水：12秒
            qingjunce: 20000   // 清君侧：20秒
        };

        // 方块形状定义
        const TETROMINOES = {
            I: {
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                className: 'i'
            },
            J: {
                shape: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                className: 'j'
            },
            L: {
                shape: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                className: 'l'
            },
            O: {
                shape: [
                    [1, 1],
                    [1, 1]
                ],
                className: 'o'
            },
            S: {
                shape: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                className: 's'
            },
            T: {
                shape: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                className: 't'
            },
            Z: {
                shape: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                className: 'z'
            }
        };

        // 剧情定义
        const STORIES = {
            SHIJUNZHILU: {
                name: "🍚 食君之禄",
                description: "食君之禄，为君分忧。",
                effect: "👻 需消耗【海棠】🌸x1支付报酬，否则将出现黑色怨气。",
                effectFunc: handleShijunzhilu,
                canAppear: true
            },
            NIGHTFALL: {
                name: "🌙 夜幕降临",
                description: "太阳没有出来之前，我是无敌的。",
                effect: "👀 需消耗【墨镜】🕶️x1适应黑暗，否则将被剥夺视线5秒。",
                effectFunc: handleNightFall,
                canAppear: true
            },
            IMMORTAL: {
                name: "🧬 长生者",
                description: "这个人汉姓姓齐，家族显赫，他没有受过什么正规的教育，在德国有一个音乐和解剖学的学位。",
                effect: "⏳ 方块下落时间放缓为0.5倍，持续10秒。",
                effectFunc: activateImmortal,
                canAppear: true
            },
            FRIED_LIVER: {
                name: "🍲 炒肝",
                description: "-今天晚上我想吃炒肝。 -我们能天亮之后去吃吗？天亮之后如果你能到这来，我就带你去吃炒肝。",
                effect: "⏸️ 小小花开始吃炒肝，停止操作3秒。",
                effectFunc: activateFriedLiver,
                canAppear: true
            },
            BLOODY_WEATHER: {
                name: "🌧️ 流血的天气",
                description: "今晚要下雨，流血的天气。",
                effect: "🔴 现有及接下来的5个方块全部变为红色",
                effectFunc: activateBloodyWeather,
                canAppear: true
            },
            OPERA: {
                name: "🎭 戏曲",
                description: "如果我声带坏了，我就不能唱戏了，很多女孩子会伤心的。",
                effect: "🎵 解语花路过，更换了BGM。",
                effectFunc: activateOpera,
                canAppear: true
            },
            SNOOPY: {
                name: "🐶 史努比",
                description: "九点五十分，上床看了会儿史努比的漫画。",
                effect: "↩️ 解雨臣打开漫画，撤回这一步方块。",
                effectFunc: activateSnoopy,
                canAppear: true
            },
            BRASS_BOX: {
                name: "📦 黄铜箱子",
                description: "-很久以前的那个黄铜箱子。 -你也有那么想找回来的东西？",
                effect: "💞 找到宿命结局，分数直接变为9999。",
                effectFunc: activateBrassBox,
                canAppear: true,
                appearsOnlyOnce: true,
                hasAppeared: false
            },
            TICKET: {
                name: "✈️ 机票",
                description: "类似于回去的机票都买不起的那种卑微。",
                effect: "💓 输入正确答案后方可继续游戏",
                effectFunc: activateTicket,
                canAppear: true
            },
            CAN_WINDMILL: {
                name: "🎡 易拉罐风车",
                description: "苏打水易拉罐diy风车手作。",
                effect: "💨 黑眼镜示范玩法，随机吹走了现有的9格方块。",
                effectFunc: activateCanWindmill,
                canAppear: true
            }
        };

        // 道具定义
        const ITEMS = {
            QINGJUNCE: {
                name: "清君侧",
                description: "清除游戏区域内的所有方块",
                effectFunc: clearAllBlocks
            },
            SODAWATER: {
                name: "苏打水",
                description: "随机改变下一个方块的形状",
                effectFunc: randomizeNextPiece
            }
        };

        // 游戏变量
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let score = 0;
        let gameOver = false;
        let isPaused = false;
        let gameStarted = false;
        let dropInterval = null;
        let dropSpeed = 1000;
        let originalDropSpeed = 1000;

        // 剧情管理系统变量
        let availableStories = [];
        let usedStories = [];
        let storyRound = 1;
        let storyCount = 0;

        // 上一个方块状态
        let previousBoard = null;
        let previousPiece = null;

        // 道具和状态变量
        let items = {
            mojing: 0,
            haitang: 0,
            qingjunce: 0,
            sodawater: 0
        };

        // 道具恢复计时器
        let itemRecoveryTimers = {
            mojing: null,
            haitang: null,
            qingjunce: null,
            sodawater: null
        };

        // 道具恢复进度
        let itemRecoveryProgress = {
            mojing: 0,
            haitang: 0,
            qingjunce: 0,
            sodawater: 0
        };

        // 状态效果
        let activeEffects = {
            nightFall: false,
            immortal: false,
            bloodyWeather: false,
            bloodyWeatherCount: 0,
            friedLiver: false,
            friedLiverTimer: null,
            yuanGhost: false
        };

        // 效果计时器
        let effectTimers = {
            nightFall: null,
            immortal: null,
            friedLiver: null,
            yuanGhost: null
        };

        // 音乐变量
        let backgroundMusic = document.getElementById('background-music');
        let operaMusic = document.getElementById('opera-music');
        let isOperaPlaying = false;
        let operaTimeout = null;

        // DOM元素
        const rulesModal = document.getElementById('rules-modal');
        const rulesConfirmButton = document.getElementById('rules-confirm-button');
        const gameBoardElement = document.getElementById('game-board');
        const nextPieceBoardElement = document.getElementById('next-piece-board');
        const scoreElement = document.getElementById('score');
        const gameStatusElement = document.getElementById('game-status');
        const startRestartButton = document.getElementById('start-restart-button');
        const pauseResumeButton = document.getElementById('pause-resume-button');

        // 道具数量显示元素
        const mojingCountElement = document.getElementById('mojing-count');
        const haitangCountElement = document.getElementById('haitang-count');
        const qingjunceCountElement = document.getElementById('qingjunce-count');
        const sodawaterCountElement = document.getElementById('sodawater-count');

        // 道具项元素
        const mojingItemElement = document.getElementById('mojing-item');
        const haitangItemElement = document.getElementById('haitang-item');
        const qingjunceItemElement = document.getElementById('qingjunce-item');
        const sodawaterItemElement = document.getElementById('sodawater-item');

        // 道具恢复进度条元素
        const mojingRecoveryElement = document.getElementById('mojing-recovery');
        const haitangRecoveryElement = document.getElementById('haitang-recovery');
        const qingjunceRecoveryElement = document.getElementById('qingjunce-recovery');
        const sodawaterRecoveryElement = document.getElementById('sodawater-recovery');

        // 事件弹窗元素
        const eventModal = document.getElementById('event-modal');
        const eventTitleElement = document.getElementById('event-title');
        const eventDescriptionElement = document.getElementById('event-description');
        const eventActionsElement = document.getElementById('event-actions');

        // 触摸控制变量
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const SWIPE_THRESHOLD = 30;
        const TAP_THRESHOLD = 10;

        // 音乐控制函数
        function playBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.currentTime = 0;
                backgroundMusic.play().catch(e => console.log("背景音乐播放失败:", e));
            }
        }

        function pauseBackgroundMusic() {
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
            }
        }

        function stopOperaMusic() {
            if (operaMusic && !operaMusic.paused) {
                operaMusic.pause();
                operaMusic.currentTime = 0;
                isOperaPlaying = false;
                if (operaTimeout) {
                    clearTimeout(operaTimeout);
                    operaTimeout = null;
                }
            }
        }

        function playOperaMusic() {
            if (isOperaPlaying) return;

            isOperaPlaying = true;
            if (backgroundMusic && !backgroundMusic.paused) {
                backgroundMusic.pause();
            }

            if (operaMusic) {
                operaMusic.currentTime = 0;
                operaMusic.play().catch(e => console.log("戏曲音乐播放失败:", e));

                operaMusic.onended = function () {
                    isOperaPlaying = false;
                    if (gameStarted && !isPaused && !gameOver) {
                        playBackgroundMusic();
                    }
                };

                if (operaTimeout) clearTimeout(operaTimeout);
                operaTimeout = setTimeout(() => {
                    if (isOperaPlaying) {
                        stopOperaMusic();
                        if (gameStarted && !isPaused && !gameOver) {
                            playBackgroundMusic();
                        }
                    }
                }, 30000);
            }
        }

        // 初始化游戏板
        function createBoard() {
            board = Array.from({ length: BOARD_HEIGHT }, () =>
                Array.from({ length: BOARD_WIDTH }, () => EMPTY_CELL)
            );

            gameBoardElement.innerHTML = '';
            gameBoardElement.classList.remove('night-fall', 'blood-weather', 'yuan-ghost');

            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    gameBoardElement.appendChild(cell);
                }
            }

            nextPieceBoardElement.innerHTML = '';
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    nextPieceBoardElement.appendChild(cell);
                }
            }

            updateItemDisplays();
        }

        // 获取随机方块
        function getRandomPiece() {
            const tetrominoNames = Object.keys(TETROMINOES);
            const randomName = tetrominoNames[Math.floor(Math.random() * tetrominoNames.length)];
            return {
                name: randomName,
                shape: TETROMINOES[randomName].shape,
                className: TETROMINOES[randomName].className,
                row: 0,
                col: Math.floor(BOARD_WIDTH / 2) - Math.floor(TETROMINOES[randomName].shape[0].length / 2)
            };
        }

        // 保存当前方块状态
        function saveCurrentState() {
            previousBoard = JSON.parse(JSON.stringify(board));
            previousPiece = currentPiece ? JSON.parse(JSON.stringify(currentPiece)) : null;
        }

        // 绘制游戏板
        function drawBoard() {
            const cells = document.querySelectorAll('#game-board .cell');

            cells.forEach(cell => {
                cell.className = 'cell';
                cell.style.backgroundColor = '';
                cell.style.borderColor = '';
            });

            // 应用流血天气效果
            if (activeEffects.bloodyWeather) {
                gameBoardElement.classList.add('blood-weather');
            } else {
                gameBoardElement.classList.remove('blood-weather');
            }

            // 应用冤魂效果
            if (activeEffects.yuanGhost) {
                gameBoardElement.classList.add('yuan-ghost');
            } else {
                gameBoardElement.classList.remove('yuan-ghost');
            }

            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    if (board[row][col] !== EMPTY_CELL) {
                        const cellIndex = row * BOARD_WIDTH + col;
                        cells[cellIndex].classList.add('filled', board[row][col]);
                    }
                }
            }

            if (currentPiece) {
                for (let row = 0; row < currentPiece.shape.length; row++) {
                    for (let col = 0; col < currentPiece.shape[row].length; col++) {
                        if (currentPiece.shape[row][col]) {
                            const boardRow = currentPiece.row + row;
                            const boardCol = currentPiece.col + col;

                            if (boardRow >= 0 && boardRow < BOARD_HEIGHT &&
                                boardCol >= 0 && boardCol < BOARD_WIDTH) {
                                const cellIndex = boardRow * BOARD_WIDTH + boardCol;
                                cells[cellIndex].classList.add('filled', currentPiece.className);
                            }
                        }
                    }
                }
            }
        }

        // 绘制下一个方块预览
        function drawNextPiece() {
            const cells = document.querySelectorAll('#next-piece-board .cell');

            cells.forEach(cell => {
                cell.className = 'cell';
                cell.textContent = '';
                cell.style.backgroundColor = '';
                cell.style.borderColor = '';
            });

            if (nextPiece) {
                const offsetX = Math.floor((4 - nextPiece.shape[0].length) / 2);
                const offsetY = Math.floor((4 - nextPiece.shape.length) / 2);

                for (let row = 0; row < nextPiece.shape.length; row++) {
                    for (let col = 0; col < nextPiece.shape[row].length; col++) {
                        if (nextPiece.shape[row][col]) {
                            const previewRow = row + offsetY;
                            const previewCol = col + offsetX;
                            const cellIndex = previewRow * 4 + previewCol;

                            if (cellIndex >= 0 && cellIndex < cells.length) {
                                cells[cellIndex].classList.add('filled', nextPiece.className);
                            }
                        }
                    }
                }
            }
        }

        // 更新道具显示和状态
        function updateItemDisplays() {
            mojingCountElement.textContent = items.mojing;
            haitangCountElement.textContent = items.haitang;
            qingjunceCountElement.textContent = items.qingjunce;
            sodawaterCountElement.textContent = items.sodawater;

            // 更新恢复进度条
            updateRecoveryBars();

            // 更新道具项状态
            updateItemStates();
        }

        // 更新恢复进度条
        function updateRecoveryBars() {
            mojingRecoveryElement.style.width = `${itemRecoveryProgress.mojing}%`;
            haitangRecoveryElement.style.width = `${itemRecoveryProgress.haitang}%`;
            qingjunceRecoveryElement.style.width = `${itemRecoveryProgress.qingjunce}%`;
            sodawaterRecoveryElement.style.width = `${itemRecoveryProgress.sodawater}%`;
        }

        // 更新道具项状态
        function updateItemStates() {
            // 清君侧
            if (items.qingjunce > 0) {
                qingjunceItemElement.classList.remove('disabled');
                qingjunceItemElement.classList.add('recovered');
            } else {
                qingjunceItemElement.classList.add('disabled');
                qingjunceItemElement.classList.remove('recovered');
            }

            // 苏打水
            if (items.sodawater > 0) {
                sodawaterItemElement.classList.remove('disabled');
                sodawaterItemElement.classList.add('recovered');
            } else {
                sodawaterItemElement.classList.add('disabled');
                sodawaterItemElement.classList.remove('recovered');
            }

            // 海棠
            if (items.haitang > 0) {
                haitangItemElement.classList.remove('disabled');
                haitangItemElement.classList.add('recovered');
            } else {
                haitangItemElement.classList.add('disabled');
                haitangItemElement.classList.remove('recovered');
            }

            // 墨镜
            if (items.mojing > 0) {
                mojingItemElement.classList.remove('disabled');
                mojingItemElement.classList.add('recovered');
            } else {
                mojingItemElement.classList.add('disabled');
                mojingItemElement.classList.remove('recovered');
            }
        }

        // 开始道具恢复计时器
        function startItemRecovery(itemType) {
            if (itemRecoveryTimers[itemType]) {
                clearInterval(itemRecoveryTimers[itemType]);
            }

            if (items[itemType] > 0) {
                itemRecoveryProgress[itemType] = 100;
            } else {
                itemRecoveryProgress[itemType] = 0;
            }

            updateRecoveryBars();

            if (items[itemType] > 0) {
                return;
            }

            const recoveryTime = ITEM_RECOVERY_TIMES[itemType];
            const interval = 100;
            const steps = recoveryTime / interval;
            const increment = 100 / steps;

            let accumulatedProgress = itemRecoveryProgress[itemType];
            let lastUpdateTime = Date.now();

            itemRecoveryTimers[itemType] = setInterval(() => {
                if (isPaused || !gameStarted) return;

                const currentTime = Date.now();
                const elapsed = currentTime - lastUpdateTime;
                lastUpdateTime = currentTime;

                const progressIncrement = (elapsed / recoveryTime) * 100;
                accumulatedProgress += progressIncrement;

                if (accumulatedProgress > 100) {
                    accumulatedProgress = 100;
                }

                itemRecoveryProgress[itemType] = accumulatedProgress;
                updateRecoveryBars();

                if (accumulatedProgress >= 100) {
                    clearInterval(itemRecoveryTimers[itemType]);
                    itemRecoveryTimers[itemType] = null;
                    itemRecoveryProgress[itemType] = 100;
                    items[itemType]++;
                    updateItemDisplays();
                }
            }, interval);
        }

        // 使用道具
        function useItem(itemType) {
            if (items[itemType] <= 0) {
                const itemElement = document.getElementById(`${itemType}-item`);
                itemElement.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    itemElement.style.transform = '';
                }, 300);
                return false;
            }

            items[itemType]--;
            updateItemDisplays();

            itemRecoveryProgress[itemType] = 0;
            updateRecoveryBars();

            startItemRecovery(itemType);

            return true;
        }

        // 检查碰撞
        function checkCollision(piece, rowOffset = 0, colOffset = 0) {
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const newRow = piece.row + row + rowOffset;
                        const newCol = piece.col + col + colOffset;

                        if (
                            newRow >= BOARD_HEIGHT ||
                            newCol < 0 ||
                            newCol >= BOARD_WIDTH ||
                            (newRow >= 0 && board[newRow][newCol] !== EMPTY_CELL)
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 移动方块
        function movePiece(rowOffset, colOffset) {
            if (!currentPiece || gameOver || isPaused || !gameStarted) return false;

            if (activeEffects.friedLiver) return false;

            if (!checkCollision(currentPiece, rowOffset, colOffset)) {
                currentPiece.row += rowOffset;
                currentPiece.col += colOffset;
                drawBoard();
                return true;
            }

            if (rowOffset > 0 && colOffset === 0) {
                lockPiece();
                return false;
            }

            return false;
        }

        // 旋转方块
        function rotatePiece() {
            if (!currentPiece || gameOver || isPaused || !gameStarted) return;

            if (activeEffects.friedLiver) return;

            const originalShape = currentPiece.shape;
            const originalCol = currentPiece.col;
            const originalRow = currentPiece.row;

            const rotatedShape = [];
            const rows = originalShape.length;
            const cols = originalShape[0].length;

            for (let col = 0; col < cols; col++) {
                const newRow = [];
                for (let row = rows - 1; row >= 0; row--) {
                    newRow.push(originalShape[row][col]);
                }
                rotatedShape.push(newRow);
            }

            currentPiece.shape = rotatedShape;

            const kicks = [
                [0, 0],
                [0, -1],
                [0, 1],
                [-1, 0],
                [1, 0]
            ];

            let canRotate = false;

            for (const [rowOffset, colOffset] of kicks) {
                currentPiece.row = originalRow + rowOffset;
                currentPiece.col = originalCol + colOffset;

                if (!checkCollision(currentPiece)) {
                    canRotate = true;
                    break;
                }
            }

            if (!canRotate) {
                currentPiece.shape = originalShape;
                currentPiece.row = originalRow;
                currentPiece.col = originalCol;
            }

            drawBoard();
        }

        // 直接落下方块
        function dropPiece() {
            if (!currentPiece || gameOver || isPaused || !gameStarted) return;

            if (activeEffects.friedLiver) return;

            while (movePiece(1, 0)) {
                // 持续向下移动直到碰撞
            }
        }

        // 固定方块到游戏板
        function lockPiece() {
            if (!currentPiece) return;

            saveCurrentState();

            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        const boardRow = currentPiece.row + row;
                        const boardCol = currentPiece.col + col;

                        if (boardRow >= 0) {
                            board[boardRow][boardCol] = currentPiece.className;
                        }
                    }
                }
            }

            clearLines();

            currentPiece = nextPiece;
            nextPiece = getRandomPiece();
            drawNextPiece();

            if (checkCollision(currentPiece)) {
                gameOver = true;
                gameStatusElement.textContent = "游戏结束!";
                clearInterval(dropInterval);
                dropInterval = null;
                pauseResumeButton.disabled = true;
                pauseResumeButton.textContent = "暂停";
                pauseBackgroundMusic();
                stopOperaMusic();
            }

            drawBoard();
        }

        // 清除完整的行
        function clearLines() {
            let linesCleared = 0;

            for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
                if (board[row].every(cell => cell !== EMPTY_CELL)) {
                    board.splice(row, 1);
                    board.unshift(Array.from({ length: BOARD_WIDTH }, () => EMPTY_CELL));
                    linesCleared++;
                    row++;
                }
            }

            if (linesCleared > 0) {
                score += linesCleared * 100;
                scoreElement.textContent = score;
                gameStatusElement.textContent = `消除了 ${linesCleared} 行!`;

                setTimeout(() => {
                    triggerRandomStory();
                }, 500);
            } else {
                if (!gameOver && !isPaused && gameStarted) {
                    gameStatusElement.textContent = "游戏中";
                }
            }
        }

        // 初始化剧情系统
        function initStorySystem() {
            availableStories = [];
            usedStories = [];
            storyRound = 1;
            storyCount = 0;

            for (const key in STORIES) {
                if (key !== 'BRASS_BOX') {
                    STORIES[key].canAppear = true;
                } else {
                    STORIES[key].canAppear = false;
                    STORIES[key].hasAppeared = false;
                }
            }
        }

        // 打乱数组顺序
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // 获取下一个随机剧情
        function getNextRandomStory() {
            storyCount++;

            if (storyCount > 3 && !STORIES.BRASS_BOX.hasAppeared) {
                STORIES.BRASS_BOX.canAppear = true;
            }

            availableStories = [];
            for (const key in STORIES) {
                if (STORIES[key].canAppear && !usedStories.includes(key)) {
                    if (STORIES[key].appearsOnlyOnce && STORIES[key].hasAppeared) {
                        continue;
                    }
                    availableStories.push(key);
                }
            }

            if (availableStories.length === 0) {
                usedStories = [];
                storyRound++;

                for (const key in STORIES) {
                    if (STORIES[key].canAppear) {
                        if (STORIES[key].appearsOnlyOnce && STORIES[key].hasAppeared) {
                            continue;
                        }
                        availableStories.push(key);
                    }
                }

                shuffleArray(availableStories);
            }

            const randomIndex = Math.floor(Math.random() * availableStories.length);
            const storyKey = availableStories[randomIndex];

            availableStories.splice(randomIndex, 1);
            usedStories.push(storyKey);

            if (STORIES[storyKey].appearsOnlyOnce) {
                STORIES[storyKey].hasAppeared = true;
                STORIES[storyKey].canAppear = false;
            }

            return STORIES[storyKey];
        }

        // 清除所有现有效果
        function clearAllEffects() {
            // 清除夜幕降临效果
            if (activeEffects.nightFall) {
                gameBoardElement.classList.remove('night-fall');
                activeEffects.nightFall = false;
                if (effectTimers.nightFall) {
                    clearTimeout(effectTimers.nightFall);
                    effectTimers.nightFall = null;
                }
                const warning = document.querySelector('.night-warning');
                if (warning && warning.parentNode) {
                    warning.remove();
                }
            }

            // 清除长生者效果
            if (activeEffects.immortal) {
                activeEffects.immortal = false;
                dropSpeed = originalDropSpeed;
                updateDropSpeed();
                if (effectTimers.immortal) {
                    clearTimeout(effectTimers.immortal);
                    effectTimers.immortal = null;
                }
            }

            // 清除炒肝效果
            if (activeEffects.friedLiver) {
                activeEffects.friedLiver = false;
                if (effectTimers.friedLiver) {
                    clearTimeout(effectTimers.friedLiver);
                    effectTimers.friedLiver = null;
                }
                const freezeOverlay = document.querySelector('.freeze-overlay');
                if (freezeOverlay && freezeOverlay.parentNode) {
                    freezeOverlay.remove();
                }
            }

            // 清除流血天气效果
            if (activeEffects.bloodyWeather) {
                activeEffects.bloodyWeather = false;
                activeEffects.bloodyWeatherCount = 0;
                gameBoardElement.classList.remove('blood-weather');
            }

            // 清除冤魂效果
            if (activeEffects.yuanGhost) {
                activeEffects.yuanGhost = false;
                if (effectTimers.yuanGhost) {
                    clearTimeout(effectTimers.yuanGhost);
                    effectTimers.yuanGhost = null;
                }
            }

            drawBoard();
        }

        // 触发随机剧情
        function triggerRandomStory() {
            if (gameOver || isPaused) return;

            clearInterval(dropInterval);
            isPaused = true;

            const story = getNextRandomStory();
            showStoryModal(story);
        }

        // 显示剧情弹窗
        function showStoryModal(story) {
            eventTitleElement.textContent = story.name;
            eventDescriptionElement.textContent = story.description + "\n\n" + story.effect;

            eventActionsElement.innerHTML = '';

            if (story.name.includes("食君之禄")) {
                const consumeButton = document.createElement('button');
                consumeButton.className = 'event-button consume';
                consumeButton.textContent = `支付1朵【海棠】🌸`;
                consumeButton.onclick = () => {
                    if (items.haitang > 0) {
                        items.haitang--;
                        updateItemDisplays();
                        startItemRecovery('haitang');
                        clearAllEffects();
                        resumeGame();
                    } else {
                        handleYuanGhost();
                    }
                };

                const cancelButton = document.createElement('button');
                cancelButton.className = 'event-button cancel';
                cancelButton.textContent = '拒绝支付';
                cancelButton.onclick = () => {
                    handleYuanGhost();
                };

                eventActionsElement.appendChild(consumeButton);
                eventActionsElement.appendChild(cancelButton);

            } else if (story.name.includes("夜幕降临")) {
                const consumeButton = document.createElement('button');
                consumeButton.className = 'event-button consume';
                consumeButton.textContent = `使用1副【墨镜】🕶️`;
                consumeButton.onclick = () => {
                    if (items.mojing > 0) {
                        items.mojing--;
                        updateItemDisplays();
                        startItemRecovery('mojing');
                        clearAllEffects();
                        resumeGame();
                    } else {
                        handleNightFallWithoutMojing();
                    }
                };

                const cancelButton = document.createElement('button');
                cancelButton.className = 'event-button cancel';
                cancelButton.textContent = '拒绝使用';
                cancelButton.onclick = () => {
                    handleNightFallWithoutMojing();
                };

                eventActionsElement.appendChild(consumeButton);
                eventActionsElement.appendChild(cancelButton);

            } else {
                const confirmButton = document.createElement('button');
                confirmButton.className = 'event-button';
                confirmButton.textContent = '确认继续';
                confirmButton.onclick = () => {
                    clearAllEffects();
                    resumeGame();
                    story.effectFunc();
                };

                eventActionsElement.appendChild(confirmButton);
            }

            eventModal.classList.add('active');
        }

        // 恢复游戏
        function resumeGame() {
            eventModal.classList.remove('active');
            isPaused = false;
            if (!gameOver && gameStarted) {
                dropInterval = setInterval(() => {
                    movePiece(1, 0);
                }, dropSpeed);
                gameStatusElement.textContent = "游戏中";
            }
        }

        // 处理食君之禄剧情
        function handleShijunzhilu() {
            console.log("食君之禄剧情处理");
        }

        // 处理冤魂效果
        function handleYuanGhost() {
            clearAllEffects();
            activeEffects.yuanGhost = true;

            eventModal.classList.remove('active');

            const yuanModal = document.createElement('div');
            yuanModal.className = 'event-modal active';
            yuanModal.innerHTML = `
                    <div class="event-content">
                        <div style="font-size: 6rem; color: white; margin: 20px 0;">冤</div>
                        <div class="event-description">黑眼镜把发票贴成一个冤字</div>
                        <button class="event-button" id="confirm-yuan-button">确认</button>
                    </div>
                `;

            document.body.appendChild(yuanModal);

            drawBoard();

            effectTimers.yuanGhost = setTimeout(() => {
                activeEffects.yuanGhost = false;
                drawBoard();
                gameStatusElement.textContent = "冤魂散去";
                setTimeout(() => {
                    if (!gameOver && !isPaused && gameStarted) {
                        gameStatusElement.textContent = "游戏中";
                    }
                }, 2000);
            }, 20000);

            document.getElementById('confirm-yuan-button').onclick = () => {
                yuanModal.remove();
                resumeGame();
            };
        }

        // 处理夜幕降临（没有墨镜的情况）
        function handleNightFallWithoutMojing() {
            clearAllEffects();
            eventModal.classList.remove('active');

            activeEffects.nightFall = true;
            gameBoardElement.classList.add('night-fall');

            const warning = document.createElement('div');
            warning.style.position = 'absolute';
            warning.style.top = '50%';
            warning.style.left = '50%';
            warning.style.transform = 'translate(-50%, -50%)';
            warning.style.color = 'white';
            warning.style.fontSize = '1.5rem';
            warning.style.textAlign = 'center';
            warning.textContent = "夜幕降临\n5秒后恢复";
            gameBoardElement.appendChild(warning);

            resumeGame();

            effectTimers.nightFall = setTimeout(() => {
                activeEffects.nightFall = false;
                gameBoardElement.classList.remove('night-fall');
                if (warning.parentNode) {
                    warning.remove();
                }
                gameStatusElement.textContent = "夜幕散去";
                setTimeout(() => {
                    if (!gameOver && !isPaused && gameStarted) {
                        gameStatusElement.textContent = "游戏中";
                    }
                }, 2000);
            }, 5000);
        }

        // 长生者效果
        function activateImmortal() {
            clearAllEffects();
            activeEffects.immortal = true;
            originalDropSpeed = dropSpeed;
            dropSpeed *= 2;
            updateDropSpeed();
            gameStatusElement.textContent = "方块下落速度变慢";

            effectTimers.immortal = setTimeout(() => {
                if (activeEffects.immortal) {
                    activeEffects.immortal = false;
                    dropSpeed = originalDropSpeed;
                    updateDropSpeed();
                    gameStatusElement.textContent = "变慢效果结束";
                    setTimeout(() => {
                        if (!gameOver && !isPaused && gameStarted) {
                            gameStatusElement.textContent = "游戏中";
                        }
                    }, 1000);
                }
            }, 10000);
        }

        // 炒肝效果
        function activateFriedLiver() {
            clearAllEffects();

            setTimeout(() => {
                if (activeEffects.friedLiver) return;

                activeEffects.friedLiver = true;
                gameStatusElement.textContent = "操作被冻结3秒";

                const freezeOverlay = document.createElement('div');
                freezeOverlay.style.position = 'absolute';
                freezeOverlay.style.top = '0';
                freezeOverlay.style.left = '0';
                freezeOverlay.style.width = '100%';
                freezeOverlay.style.height = '100%';
                freezeOverlay.style.backgroundColor = 'rgba(139, 69, 19, 0.3)';
                freezeOverlay.style.display = 'flex';
                freezeOverlay.style.justifyContent = 'center';
                freezeOverlay.style.alignItems = 'center';
                freezeOverlay.style.borderRadius = '6px';

                const freezeText = document.createElement('div');
                freezeText.textContent = "🌸 吃炒肝中";
                freezeText.style.color = '#ff9ec9';
                freezeText.style.fontSize = '2rem';
                freezeText.style.fontWeight = 'bold';
                freezeOverlay.appendChild(freezeText);
                gameBoardElement.appendChild(freezeOverlay);

                effectTimers.friedLiver = setTimeout(() => {
                    activeEffects.friedLiver = false;
                    if (freezeOverlay.parentNode) {
                        freezeOverlay.remove();
                    }
                    gameStatusElement.textContent = "炒肝吃完啦";
                    setTimeout(() => {
                        if (!gameOver && !isPaused && gameStarted) {
                            gameStatusElement.textContent = "游戏中";
                        }
                    }, 2000);
                }, 3000);
            }, 100);
        }

        // 流血天气效果
        function activateBloodyWeather() {
            clearAllEffects();
            activeEffects.bloodyWeather = true;
            activeEffects.bloodyWeatherCount = 5;
            gameStatusElement.textContent = "接下来5个方块变为红色";
            drawBoard();
            drawNextPiece();
        }

        // 戏曲效果
        function activateOpera() {
            gameStatusElement.textContent = "播放BGM《霸王别姬》";
            playOperaMusic();
            setTimeout(() => {
                if (!gameOver && !isPaused && gameStarted) {
                    gameStatusElement.textContent = "游戏中";
                }
            }, 3000);
        }

        // 史努比效果
        function activateSnoopy() {
            if (previousBoard && previousPiece) {
                clearAllEffects();
                board = JSON.parse(JSON.stringify(previousBoard));
                currentPiece = JSON.parse(JSON.stringify(previousPiece));
                drawBoard();
                gameStatusElement.textContent = "撤回了一步";
                setTimeout(() => {
                    if (!gameOver && !isPaused && gameStarted) {
                        gameStatusElement.textContent = "游戏中";
                    }
                }, 2000);
            } else {
                gameStatusElement.textContent = "史努比出现，但没有可撤回的步骤";
                setTimeout(() => {
                    if (!gameOver && !isPaused && gameStarted) {
                        gameStatusElement.textContent = "游戏中";
                    }
                }, 2000);
            }
        }

        // 黄铜箱子效果
        function activateBrassBox() {
            clearAllEffects();
            score = 9999;
            scoreElement.textContent = score;
            gameStatusElement.textContent = "分数变为9999";
            setTimeout(() => {
                if (!gameOver && !isPaused && gameStarted) {
                    gameStatusElement.textContent = "游戏中";
                }
            }, 2000);
        }

        // 机票效果
        function activateTicket() {
            console.log("机票剧情激活");
        }

        // 易拉罐风车效果
        function activateCanWindmill() {
            clearAllEffects();

            const filledCells = [];
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    if (board[row][col] !== EMPTY_CELL) {
                        filledCells.push({ row, col });
                    }
                }
            }

            if (filledCells.length === 0) {
                gameStatusElement.textContent = "易拉罐风车转动，但没有方块可消除";
                setTimeout(() => {
                    if (!gameOver && !isPaused && gameStarted) {
                        gameStatusElement.textContent = "游戏中";
                    }
                }, 2000);
                return;
            }

            const cellsToRemove = Math.min(9, filledCells.length);
            const removedPositions = [];

            for (let i = 0; i < cellsToRemove; i++) {
                const randomIndex = Math.floor(Math.random() * filledCells.length);
                const cell = filledCells[randomIndex];
                removedPositions.push({ ...cell });
                filledCells.splice(randomIndex, 1);
                board[cell.row][cell.col] = EMPTY_CELL;
            }

            for (const pos of removedPositions) {
                for (let row = pos.row - 1; row >= 0; row--) {
                    if (board[row][pos.col] !== EMPTY_CELL) {
                        board[row + 1][pos.col] = board[row][pos.col];
                        board[row][pos.col] = EMPTY_CELL;
                    }
                }
            }

            drawBoard();
            gameStatusElement.textContent = `消除了${cellsToRemove}个方块`;
            setTimeout(() => {
                if (!gameOver && !isPaused && gameStarted) {
                    gameStatusElement.textContent = "游戏中";
                }
            }, 2000);
        }

        // 道具效果函数
        function clearAllBlocks() {
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    board[row][col] = EMPTY_CELL;
                }
            }
            drawBoard();
            gameStatusElement.textContent = "所有方块已清除";
            setTimeout(() => {
                if (!gameOver && !isPaused && gameStarted) {
                    gameStatusElement.textContent = "游戏中";
                }
            }, 2000);
        }

        function randomizeNextPiece() {
            nextPiece = getRandomPiece();
            drawNextPiece();
            gameStatusElement.textContent = "下一个方块已改变";
            setTimeout(() => {
                if (!gameOver && !isPaused && gameStarted) {
                    gameStatusElement.textContent = "游戏中";
                }
            }, 2000);
        }

        // 更新下落速度
        function updateDropSpeed() {
            if (dropInterval) {
                clearInterval(dropInterval);
                dropInterval = setInterval(() => {
                    movePiece(1, 0);
                }, dropSpeed);
            }
        }

        // 开始/重新开始游戏
        function startOrRestartGame() {
            if (gameStarted && !gameOver) {
                resetGame();
                startGame();
            } else {
                resetGame();
                showRulesModal();
            }
        }

        // 显示规则弹窗
        function showRulesModal() {
            rulesModal.classList.add('active');
            startRestartButton.disabled = true;
            pauseResumeButton.disabled = true;
        }

        // 隐藏规则弹窗并开始游戏
        function hideRulesModalAndStartGame() {
            rulesModal.classList.remove('active');
            startRestartButton.disabled = false;
            startGame();
        }

        // 开始游戏
        function startGame() {
            gameStarted = true;
            gameOver = false;
            isPaused = false;
            gameStatusElement.textContent = "游戏中";
            startRestartButton.textContent = "重新开始";
            pauseResumeButton.disabled = false;

            initStorySystem();

            items = {
                mojing: 0,
                haitang: 0,
                qingjunce: 0,
                sodawater: 0
            };

            for (const itemType in itemRecoveryTimers) {
                if (itemRecoveryTimers[itemType]) {
                    clearInterval(itemRecoveryTimers[itemType]);
                    itemRecoveryTimers[itemType] = null;
                }
                itemRecoveryProgress[itemType] = 0;
            }

            startItemRecovery('mojing');
            startItemRecovery('haitang');
            startItemRecovery('qingjunce');
            startItemRecovery('sodawater');

            updateItemDisplays();

            clearAllEffects();

            gameBoardElement.classList.remove('night-fall', 'blood-weather', 'yuan-ghost');

            if (!currentPiece) {
                currentPiece = getRandomPiece();
            }

            if (!nextPiece) {
                nextPiece = getRandomPiece();
                drawNextPiece();
            }

            dropSpeed = 1000;
            originalDropSpeed = 1000;

            if (dropInterval) {
                clearInterval(dropInterval);
            }

            dropInterval = setInterval(() => {
                movePiece(1, 0);
            }, dropSpeed);

            playBackgroundMusic();

            drawBoard();
        }

        // 暂停/继续游戏
        function togglePauseResume() {
            if (gameOver || !gameStarted) return;

            isPaused = !isPaused;

            if (isPaused) {
                clearInterval(dropInterval);
                gameStatusElement.textContent = "已暂停";
                pauseResumeButton.textContent = "继续";
            } else {
                gameStatusElement.textContent = "游戏中";
                pauseResumeButton.textContent = "暂停";

                dropInterval = setInterval(() => {
                    movePiece(1, 0);
                }, dropSpeed);
            }
        }

        // 重置游戏状态
        function resetGame() {
            if (dropInterval) {
                clearInterval(dropInterval);
                dropInterval = null;
            }

            for (const itemType in itemRecoveryTimers) {
                if (itemRecoveryTimers[itemType]) {
                    clearInterval(itemRecoveryTimers[itemType]);
                    itemRecoveryTimers[itemType] = null;
                }
                itemRecoveryProgress[itemType] = 0;
            }

            for (const timer in effectTimers) {
                if (effectTimers[timer]) {
                    clearTimeout(effectTimers[timer]);
                    effectTimers[timer] = null;
                }
            }

            score = 0;
            gameOver = false;
            isPaused = false;
            gameStarted = false;
            dropSpeed = 1000;

            clearAllEffects();

            previousBoard = null;
            previousPiece = null;

            rulesModal.classList.remove('active');

            startRestartButton.disabled = false;

            pauseBackgroundMusic();
            stopOperaMusic();
            isOperaPlaying = false;

            scoreElement.textContent = score;
            gameStatusElement.textContent = "准备开始";
            startRestartButton.textContent = "开始游戏";
            pauseResumeButton.textContent = "暂停";
            pauseResumeButton.disabled = true;

            createBoard();
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            drawNextPiece();
            drawBoard();
        }

        // 设置触摸控制
        function setupTouchControls() {
            // 棋盘触摸事件
            gameBoardElement.addEventListener('touchstart', handleTouchStart);
            gameBoardElement.addEventListener('touchmove', handleTouchMove);
            gameBoardElement.addEventListener('touchend', handleTouchEnd);

            // 道具点击事件
            qingjunceItemElement.addEventListener('click', () => {
                if (useItem('qingjunce')) {
                    ITEMS.QINGJUNCE.effectFunc();
                }
            });

            sodawaterItemElement.addEventListener('click', () => {
                if (useItem('sodawater')) {
                    ITEMS.SODAWATER.effectFunc();
                }
            });

            // 防止触摸滚动
            gameBoardElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
            });
        }

        // 触摸开始处理
        function handleTouchStart(e) {
            if (!gameStarted || isPaused || gameOver) return;

            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;

            e.preventDefault();
        }

        // 触摸移动处理
        function handleTouchMove(e) {
            if (!gameStarted || isPaused || gameOver) return;
            e.preventDefault();
        }

        // 触摸结束处理
        function handleTouchEnd(e) {
            if (!gameStarted || isPaused || gameOver || !touchStartX || !touchStartY) return;

            const touch = e.changedTouches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            // 判断滑动方向
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // 水平滑动
                if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
                    if (deltaX > 0) {
                        // 右滑 - 右移
                        movePiece(0, 1);
                    } else {
                        // 左滑 - 左移
                        movePiece(0, -1);
                    }
                }
            } else {
                // 垂直滑动
                if (Math.abs(deltaY) > SWIPE_THRESHOLD) {
                    if (deltaY > 0) {
                        // 下滑 - 加速下落
                        let moved = false;
                        while (movePiece(1, 0)) {
                            moved = true;
                        }
                        if (!moved) {
                            // 如果不能再下落，尝试旋转
                            rotatePiece();
                        }
                    } else {
                        // 上滑 - 旋转
                        rotatePiece();
                    }
                } else {
                    // 轻触 - 快速下落
                    if (Math.abs(deltaX) < TAP_THRESHOLD && Math.abs(deltaY) < TAP_THRESHOLD) {
                        dropPiece();
                    }
                }
            }

            // 重置触摸位置
            touchStartX = 0;
            touchStartY = 0;
            touchEndX = 0;
            touchEndY = 0;

            e.preventDefault();
        }

        // 键盘控制（可选）
        function handleKeyDown(event) {
            if (!gameStarted && event.key !== 'Enter') return;

            switch (event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    movePiece(0, -1);
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    movePiece(0, 1);
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    movePiece(1, 0);
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    rotatePiece();
                    break;
                case ' ':
                    event.preventDefault();
                    dropPiece();
                    break;
                case 'p':
                case 'P':
                    event.preventDefault();
                    togglePauseResume();
                    break;
                case 'Enter':
                    event.preventDefault();
                    startOrRestartGame();
                    break;
            }
        }

        // 初始化游戏
        function init() {
            createBoard();
            resetGame();

            document.addEventListener('keydown', handleKeyDown);
            startRestartButton.addEventListener('click', startOrRestartGame);
            pauseResumeButton.addEventListener('click', togglePauseResume);
            rulesConfirmButton.addEventListener('click', hideRulesModalAndStartGame);

            setupTouchControls();

            drawBoard();
            drawNextPiece();

            // 调整棋盘大小以确保格子是正方形
            setTimeout(adjustBoardSize, 100);
        }

        // 调整棋盘大小
        function adjustBoardSize() {
            const boardContainer = document.querySelector('.game-board-container');
            const board = document.querySelector('.game-board');

            if (boardContainer && board) {
                const containerWidth = boardContainer.clientWidth;
                const containerHeight = boardContainer.clientHeight;

                // 保持10:20的比例，确保格子是正方形
                const cellSize = Math.min(containerWidth / 10, containerHeight / 20);
                const boardWidth = cellSize * 10;
                const boardHeight = cellSize * 20;

                board.style.width = boardWidth + 'px';
                board.style.height = boardHeight + 'px';
            }
        }

        // 监听窗口大小变化
        window.addEventListener('resize', adjustBoardSize);

        // 页面加载完成后初始化游戏
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>